[EN](https://github.com/avtomatika-ai/avtomatika/blob/main/README.md) | [ES](https://github.com/avtomatika-ai/avtomatika/blob/main/docs/es/README.md) | **RU**

# Оркестратор Avtomatika

Avtomatika — это мощный движок для управления сложными асинхронными рабочими процессами на Python, основанный на конечных автоматах. Он предоставляет надежный фреймворк для создания масштабируемых и отказоустойчивых приложений, разделяя логику процесса и логику выполнения.

Этот документ служит исчерпывающим руководством для разработчиков, желающих создавать пайплайны (блупринты) и встраивать Оркестратор в свои приложения.

## Оглавление
- [Основная концепция: Оркестратор, Блупринты и Воркеры](#основная-концепция-оркестратор-блупринты-и-воркеры)
- [Установка](#установка)
- [Быстрый старт: Использование в качестве библиотеки](#быстрый-старт-использование-в-качестве-библиотеки)
- [Ключевые концепции: JobContext и Actions](#ключевые-концепции-jobcontext-и-actions)
- [Cookbook Блупринтов: Ключевые возможности](#cookbook-блупринтов-ключевые-возможности)
  - [Условные переходы (.when())](#условные-переходы-when)
  - [Делегирование задач Воркерам (dispatch_task)](#делегирование-задач-воркерам-dispatch_task)
  - [Параллельное выполнение и Агрегация (Fan-out/Fan-in)](#параллельное-выполнение-и-агрегация-fan-outfan-in)
  - [Внедрение зависимостей (DataStore)](#внедрение-зависимостей-datastore)
  - [Нативный Планировщик (Native Scheduler)](#нативный-планировщик-native-scheduler)
  - [S3 Payload Offloading (Работа с файлами)](#s3-payload-offloading-работа-с-файлами)
  - [Уведомления через вебхуки](#уведомления-через-вебхуки)
- [Конфигурация для Production](#конфигурация-для-production)
  - [Файлы конфигурации](#файлы-конфигурации)
  - [Отказоустойчивость](#отказоустойчивость)
  - [Высокая доступность и Распределенная блокировка](#высокая-доступность-и-распределенная-блокировка)
  - [Бэкенд хранилища](#бэкенд-хранилища)
  - [Безопасность](#безопасность)
  - [Наблюдаемость](#наблюдаемость)
- [Руководство участника](#руководство-участника)
  - [Настройка окружения](#настройка-окружения)
  - [Запуск тестов](#запуск-тестов)
- [Интерактивная документация API](#интерактивная-документация-api)
- [Подробная документация](#подробная-документация)

## Основная концепция: Оркестратор, Блупринты и Воркеры

Проект основан на простом, но мощном архитектурном паттерне, который отделяет логику процесса от логики выполнения.

*   **Оркестратор (OrchestratorEngine)** — Режиссёр. Он управляет всем процессом от начала до конца, отслеживает состояние, обрабатывает ошибки и решает, что должно произойти дальше. Он не выполняет бизнес-задачи сам.
*   **Блупринты (Blueprint)** — Сценарий. Каждый блупринт — это детальный план (конечный автомат) для конкретного бизнес-процесса. Он описывает шаги (состояния) и правила перехода между ними.
*   **Воркеры (Worker)** — Команда специалистов. Это независимые, специализированные исполнители. Каждый воркер знает, как выполнять определенный набор задач (например, "обработать видео", "отправить email") и отчитывается перед Оркестратором.

## Экосистема

Avtomatika является частью более широкой экосистемы:

*   **[Avtomatika Protocol](https://github.com/avtomatika-ai/rxon)**: Общий пакет с определениями протокола, моделями данных и утилитами, обеспечивающий совместимость всех компонентов.
*   **[Avtomatika Worker SDK](https://github.com/avtomatika-ai/avtomatika-worker)**: Официальный Python SDK для создания воркеров, подключаемых к этому движку.
*   **[Протокол HLN](https://github.com/avtomatika-ai/hln)**: Архитектурная спецификация и манифест, лежащие в основе системы.
*   **[Полный пример (Full Example)](https://github.com/avtomatika-ai/avtomatika-full-example)**: Готовый эталонный проект, демонстрирующий совместную работу движка и воркеров.

## Установка

*   **Установка только ядра движка:**
    ```bash
    pip install avtomatika
    ```

*   **Установка с поддержкой Redis (рекомендуется для production):**
    ```bash
    pip install "avtomatika[redis]"
    ```

*   **Установка с поддержкой хранилища истории (SQLite, PostgreSQL):**
    ```bash
    pip install "avtomatika[history]"
    ```

*   **Установка с поддержкой телеметрии (Prometheus, OpenTelemetry):**
    ```bash
    pip install "avtomatika[telemetry]"
    ```

*   **Установка с поддержкой S3 (Payload Offloading):**
    ```bash
    pip install "avtomatika[s3]"
    ```

*   **Установка всех зависимостей, включая тестовые:**
    ```bash
    pip install "avtomatika[all,test]"
    ```

## Быстрый старт: Использование в качестве библиотеки

Вы можете легко интегрировать и запустить движок оркестратора внутри вашего собственного приложения.

```python
# my_app.py
import asyncio
from avtomatika import OrchestratorEngine, StateMachineBlueprint
from avtomatika.context import ActionFactory
from avtomatika.storage import MemoryStorage
from avtomatika.config import Config

# 1. Общая конфигурация
storage = MemoryStorage()
config = Config() # Загружает конфигурацию из переменных окружения

# Явно задаем токены для этого примера
# Токен клиента должен быть отправлен в заголовке 'X-Client-Token'.
config.CLIENT_TOKEN = "my-secret-client-token"
# Токен воркера должен быть отправлен в заголовке 'X-Worker-Token'.
config.GLOBAL_WORKER_TOKEN = "my-secret-worker-token"

# 2. Определение Блупринта рабочего процесса
my_blueprint = StateMachineBlueprint(
    name="my_first_blueprint",
    api_version="v1",
    api_endpoint="/jobs/my_flow"
)

# Используйте внедрение зависимостей, чтобы получить только нужные данные.
@my_blueprint.handler_for("start", is_start=True)
async def start_handler(job_id: str, initial_data: dict, actions: ActionFactory):
    """Начальное состояние для каждого нового задания."""
    print(f"Job {job_id} | Start: {initial_data}")
    actions.transition_to("end")

# Вы все еще можете запросить полный объект контекста, если предпочитаете.
@my_blueprint.handler_for("end", is_end=True)
async def end_handler(context):
    """Конечное состояние. Пайплайн заканчивается здесь."""
    print(f"Job {context.job_id} | Complete.")

# 3. Инициализация движка Оркестратора
engine = OrchestratorEngine(storage, config)
engine.register_blueprint(my_blueprint)

# 4. Доступ к компонентам (Опционально)
# Вы можете получить доступ к внутреннему приложению aiohttp и компонентам через AppKey
# из avtomatika.app_keys импортируйте ENGINE_KEY, DISPATCHER_KEY и др.
# app = engine.app
# dispatcher = app[DISPATCHER_KEY]

# 5. Определение главной точки входа для запуска сервера
async def main():
    await engine.start()
    
    try:
        await asyncio.Event().wait()
    finally:
        await engine.stop()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nStopping server.")
```

### Жизненный цикл движка: `run()` vs. `start()`

`OrchestratorEngine` предлагает два способа запуска сервера:

*   **`engine.run()`**: Это простой, **блокирующий** метод. Он полезен для отдельных скриптов, где оркестратор является единственным основным компонентом. Он управляет запуском и остановкой сервера за вас. Не следует использовать его внутри `async def` функции, которая является частью большего приложения, так как это может конфликтовать с циклом событий.

*   **`await engine.start()`** и **`await engine.stop()`**: Это неблокирующие методы для интеграции движка в большее `asyncio` приложение.
    *   `start()` настраивает и запускает веб-сервер в фоне.
    *   `stop()` корректно останавливает сервер и очищает ресурсы.
Пример "Быстрый старт" выше демонстрирует правильный способ использования этих методов.

## Ключевые концепции

### Высокопроизводительная Архитектура

Avtomatika спроектирована для высоконагруженных сред с тысячами конкурентных воркеров.

*   **O(1) Диспетчер**: Использует продвинутые операции над множествами Redis для мгновенного поиска воркеров.
*   **Zero Trust Security (Нулевое доверие)**:
    *   **mTLS (Mutual TLS)**: Взаимная аутентификация Оркестратора и Воркеров по сертификатам.
    *   **STS (Security Token Service)**: Механизм ротации токенов (краткосрочные access tokens).
    *   **Идентификация**: Автоматическое извлечение ID воркера из Common Name (CN) сертификата.
*   **Целостность Данных (Data Integrity)**:
    *   **Сквозная валидация**: Автоматическая проверка размера и ETag (хеша) файлов при передаче через S3.
    *   **Аудит**: Метаданные файлов сохраняются в истории задач.
*   **Слой Протокола (`rxon`)**: Все взаимодействия строятся на базе строгого контракта, обеспечивающего совместимость и возможность смены транспорта (например, на gRPC) в будущем.
*   **Non-Blocking I/O**:
    *   **Вебхуки**: Отправляются через ограниченную фоновую очередь.
    *   **S3 Streaming**: Константное потребление памяти при передаче файлов любого размера.
*   **Надежность**:
    *   **Распределенные блокировки**: Корректная работа планировщика и вочеров при горизонтальном масштабировании.
    *   **Атомарность**: Использование Lua-скриптов в Redis для критических секций.

## Книга Рецептов: Ключевые возможности

### 1. Условные переходы (`.when()`)

Используйте `.when()` для создания ветвлений условной логики. Строка условия оценивается движком до вызова обработчика, поэтому она все еще использует префикс `context.`. Сам обработчик, однако, может использовать внедрение зависимостей.

```python
# Условие `.when()` все еще ссылается на `context`.
@my_blueprint.handler_for("decision_step").when("context.initial_data.type == 'urgent'")
async def handle_urgent(actions):
    actions.transition_to("urgent_processing")

# Обработчик по умолчанию, если ни одно условие `.when()` не совпало.
@my_blueprint.handler_for("decision_step")
async def handle_normal(actions):
    actions.transition_to("normal_processing")
```

> **Примечание об ограничениях:** Текущая версия `.when()` использует простой парсер со следующими ограничениями:
> *   **Нет вложенных атрибутов:** Вы можете обращаться только к прямым полям `context.initial_data` или `context.state_history` (например, `context.initial_data.field`). Вложенные объекты (например, `context.initial_data.area.field`) не поддерживаются.
> *   **Только простые сравнения:** Поддерживаются только следующие операторы: `==`, `!=`, `>`, `<`, `>=`, `<=`. Сложные логические выражения с `AND`, `OR` или `NOT` не допускаются.
> *   **Ограниченные типы значений:** Парсер распознает только строки (в кавычках), целые числа и числа с плавающей точкой. Булевы значения (`True`, `False`) и `None` не парсятся корректно и будут рассматриваться как строки.

### 2. Делегирование задач Воркерам (`dispatch_task`)

Это основная функция для делегирования работы. Оркестратор поставит задачу в очередь и будет ждать, пока воркер заберет ее и вернет результат.

```python
@my_blueprint.handler_for("transcode_video")
async def transcode_handler(initial_data, actions):
    actions.dispatch_task(
        task_type="video_transcoding",
        params={"input_path": initial_data.get("path")},
        # Определяем следующий шаг на основе статуса ответа воркера
        transitions={
            "success": "publish_video",
            "failure": "transcoding_failed",
            "needs_review": "manual_review" # Пример кастомного статуса
        }
    )
```
Если воркер вернет статус, не указанный в `transitions`, задание автоматически перейдет в состояние сбоя.

### 3. Параллельное выполнение и Агрегация (Fan-out/Fan-in)

Запуск нескольких задач одновременно и сбор их результатов.

```python
# 1. Fan-out: Отправка нескольких задач для агрегации в одно состояние
@my_blueprint.handler_for("process_files")
async def fan_out_handler(initial_data, actions):
    tasks_to_dispatch = [
        {"task_type": "file_analysis", "params": {"file": file}})
        for file in initial_data.get("files", [])
    ]
    # Используйте dispatch_parallel, чтобы отправить все задачи сразу.
    # Все успешные задачи неявно приведут к состоянию 'aggregate_into'.
    actions.dispatch_parallel(
        tasks=tasks_to_dispatch,
        aggregate_into="aggregate_results"
    )

# 2. Fan-in: Сбор результатов с помощью декоратора @aggregator_for
@my_blueprint.aggregator_for("aggregate_results")
async def aggregator_handler(aggregation_results, state_history, actions):
    # Этот обработчик выполнится ТОЛЬКО ПОСЛЕ ТОГО, как ВСЕ задачи, 
    # отправленные через dispatch_parallel, будут завершены.

    # aggregation_results это словарь {task_id: result_dict}
    summary = [res.get("data") for res in aggregation_results.values()]
    state_history["summary"] = summary
    actions.transition_to("processing_complete")
```

### 4. Внедрение зависимостей (DataStore)

Предоставление обработчикам доступа к внешним ресурсам (например, кэшу или клиенту БД).

```python
import redis.asyncio as redis

# 1. Инициализация и регистрация вашего DataStore
redis_client = redis.Redis(decode_responses=True)
bp = StateMachineBlueprint(
    "blueprint_with_datastore",
    data_stores={"cache": redis_client}
)

# 2. Использование его в обработчике через внедрение зависимостей
@bp.handler_for("get_from_cache")
async def cache_handler(data_stores):
    # Доступ к redis_client по имени "cache"
    user_data = await data_stores.cache.get("user:123")
    print(f"User from cache: {user_data}")
```

### 5. Нативный Планировщик (Native Scheduler)

Avtomatika включает в себя встроенный распределенный планировщик. Он позволяет запускать блупринты периодически (интервально, ежедневно, еженедельно, ежемесячно) без внешних инструментов типа cron.

*   **Конфигурация:** Определяется в `schedules.toml`.
*   **Часовые пояса:** Поддерживает глобальную настройку часового пояса (например, `TZ="Europe/Moscow"`).
*   **Распределенная блокировка:** Безопасен для запуска с несколькими экземплярами оркестратора; задачи гарантированно запускаются только один раз за интервал благодаря распределенным блокировкам (Redis/Memory).

```toml
# Пример schedules.toml
[nightly_backup]
blueprint = "backup_flow"
daily_at = "02:00"
```

### 6. Вебхуки (Webhook Notifications)

Оркестратор может отправлять асинхронные уведомления во внешнюю систему при завершении, сбое или карантине задачи.

### 7. Работа с большими данными (S3 Payload Offloading)

Оркестратор предоставляет встроенную поддержку для работы с большими файлами через S3-совместимые хранилища, используя высокопроизводительную библиотеку `obstore` (Rust).

*   **Безопасность памяти (Streaming)**: Использует потоковую передачу данных для загрузки и скачивания. Это позволяет обрабатывать файлы, размер которых превышает доступную оперативную память, без риска OOM (Out-Of-Memory).
*   **Управляемый режим**: Оркестратор берет на себя управление жизненным циклом файлов (автоматическая очистка S3 объектов и локальных временных файлов после завершения задачи).
*   **Внедрение зависимостей**: Используйте аргумент `task_files` в ваших хендлерах для простого чтения/записи данных.
*   **Поддержка директорий**: Поддерживает рекурсивную загрузку и скачивание целых папок.

```python
@bp.handler_for("process_data")
async def process_data(task_files, actions):
    # Потоковое скачивание большого файла
    local_path = await task_files.download("large_dataset.csv")
    
    # ... обработка данных ...
    
    # Загрузка результата
    await task_files.write_json("results.json", {"status": "done"})
    
    actions.transition_to("finished")
```

## Конфигурация для продакшена

Поведение оркестратора можно настроить через переменные окружения. Кроме того, любой параметр конфигурации, загруженный из переменных окружения, можно программно переопределить в коде вашего приложения после инициализации объекта `Config`. Это обеспечивает гибкость для различных сценариев развертывания и тестирования.

**Важно:** Система применяет **строгую валидацию** для конфигурационных файлов (`clients.toml`, `workers.toml`) при запуске. Если конфигурационный файл невалиден (например, некорректный TOML, отсутствуют обязательные поля), приложение **быстро упадет** и завершится с ошибкой, вместо того чтобы запуститься в частично сломанном состоянии. Это обеспечивает безопасность и целостность развертывания.

### Файлы конфигурации

Для безопасного управления доступом и настройками воркеров Avtomatika использует конфигурационные файлы TOML.

-   **`clients.toml`**: Определяет API-клиентов, их токены, планы и квоты.
    ```toml
    [client_premium]
    token = "secret-token-123"
    plan = "premium"
    ```
-   **`workers.toml`**: Определяет индивидуальные токены для воркеров для повышения безопасности.
    ```toml
    [gpu-worker-01]
    token = "worker-secret-456"
    ```
-   **`schedules.toml`**: Определяет периодические задачи (аналог CRON) для нативного планировщика.
    ```toml
    [nightly_backup]
    blueprint = "backup_flow"
    daily_at = "02:00"
    ```

Подробные спецификации и примеры см. в [**Руководстве по конфигурации**](configuration.md).

### Отказоустойчивость

В оркестраторе есть встроенные механизмы обработки сбоев на основе поля `error.code` в ответе воркера.

*   **TRANSIENT_ERROR**: Временная ошибка (например, сбой сети). Оркестратор автоматически повторит задачу несколько раз.
*   **RESOURCE_EXHAUSTED_ERROR / TIMEOUT_ERROR / INTERNAL_ERROR**: Рассматриваются как временные ошибки и повторяются.
*   **PERMANENT_ERROR**: Постоянная ошибка. Задача будет немедленно отправлена в карантин.
*   **SECURITY_ERROR / DEPENDENCY_ERROR**: Рассматриваются как постоянные ошибки (нарушение безопасности или отсутствие модели). Немедленный карантин.
*   **INVALID_INPUT_ERROR**: Ошибка во входных данных. Весь пайплайн (Job) будет немедленно переведен в состояние сбоя.

### Отслеживание прогресса

Воркеры могут сообщать о ходе выполнения задачи в реальном времени (0-100%) и отправлять статусные сообщения. Эта информация автоматически сохраняется Оркестратором и доступна через API статуса задания (`GET /api/v1/jobs/{job_id}`).

### Конкурентность и Производительность

Для предотвращения перегрузки системы при высоком трафике, Оркестратор реализует механизм обратного давления (backpressure) для своей внутренней логики обработки задач.

*   **`EXECUTOR_MAX_CONCURRENT_JOBS`**: Ограничивает количество обработчиков задач, выполняемых одновременно внутри процесса Оркестратора (по умолчанию: `100`). Если этот лимит достигнут, новые задачи остаются в очереди Redis до тех пор, пока не освободится слот. Это гарантирует, что цикл событий (event loop) остается отзывчивым даже при огромном количестве ожидающих задач.

### Высокая доступность и Распределенная блокировка

Архитектура поддерживает горизонтальное масштабирование. Несколько экземпляров Оркестратора могут работать за балансировщиком нагрузки.

*   **API без состояния (Stateless):** API не имеет состояния; все состояние сохраняется в Redis.
*   **Идентификация экземпляра:** Каждый экземпляр должен иметь уникальный `INSTANCE_ID` (по умолчанию используется имя хоста) для корректной работы групп потребителей в Redis Streams.
*   **Распределенная блокировка:** Фоновые процессы (`Watcher`, `ReputationCalculator`) используют распределенные блокировки (через Redis `SET NX`) для координации и предотвращения гонки условий, когда активны несколько экземпляров.

### Логирование и Наблюдаемость

Avtomatika разработана для современных стеков наблюдения (ELK, Loki, Prometheus).

*   **Структурированное логирование:** По умолчанию логи выводятся в формате JSON, что упрощает их парсинг и индексацию. Можно переключить на текст через `LOG_FORMAT="text"`.
*   **Часовые пояса:** Все временные метки в логах учитывают глобальную настройку `TZ`.
*   **Трассируемость:** Логи содержат `job_id`, `worker_id` и `task_id` для полного отслеживания событий.
*   **Метрики:** Prometheus метрики доступны по адресу `/_public/metrics`, включая специальный счетчик `orchestrator_ratelimit_blocked_total` для отслеживания заблокированных запросов.

### Ограничение частоты (Rate Limiting)

Оркестратор включает встроенный гранулярный rate limiter на базе Redis для защиты от перегрузки и DDoS.

*   **Гранулярная защита:** Лимиты применяются к токену клиента (для API) или ID воркера (для Worker API).
*   **Контекстная зависимость:** Разные лимиты для разных операций:
    *   **Heartbeats:** Высокий лимит (по умолчанию 120/мин) для частых обновлений статуса.
    *   **Polling:** Средний лимит (по умолчанию 60/мин) для получения задач.
    *   **General API:** Стандартный лимит (по умолчанию 100/мин) для остальных запросов.
*   **Глобальное применение:** Middleware применяется глобально, защищая все точки входа в систему.

### Бэкенд хранилища

По умолчанию движок использует хранилище в памяти. Для production вы должны настроить персистентное хранилище через переменные окружения.

*   **Redis (StorageBackend)**: Для хранения текущих состояний заданий (сериализованных через `msgpack`) и управления очередями задач (через Redis Streams с группами потребителей).
    *   Установка:
        ```bash
        pip install "avtomatika[redis]"
        ```
    *   Настройка:
        ```bash
        export REDIS_HOST=your_redis_host
        ```

*   **PostgreSQL/SQLite (HistoryStorage)**: Для архивации истории завершенных заданий.
    *   Установка:
        ```bash
        pip install "avtomatika[history]"
        ```
    *   Настройка:
        ```bash
        export HISTORY_DATABASE_URI=...
        ```
        *   SQLite: `sqlite:///path/to/history.db`
        *   PostgreSQL: `postgresql://user:pass@host/db`

### Безопасность

Оркестратор использует токены для аутентификации API-запросов.

*   **Аутентификация клиента**: Все API-клиенты должны предоставлять токен в заголовке `X-Client-Token`. Оркестратор проверяет этот токен по конфигурациям клиентов.
*   **Аутентификация воркера**: Воркеры должны предоставлять токен в заголовке `X-Worker-Token`.
    *   `GLOBAL_WORKER_TOKEN`: Вы можете задать глобальный токен для всех воркеров, используя эту переменную окружения. Для разработки и тестирования по умолчанию используется `"secure-worker-token"`.
    *   **Индивидуальные токены**: Для production рекомендуется определять индивидуальные токены для каждого воркера в отдельном конфигурационном файле и указывать путь к нему через переменную окружения `WORKERS_CONFIG_PATH`. Токены из этого файла хранятся в хешированном виде для безопасности.

> **Примечание о Динамической перезагрузке:** Конфигурационный файл воркеров можно перезагрузить без перезапуска оркестратора, отправив аутентифицированный `POST` запрос на эндпоинт `/api/v1/admin/reload-workers`. Это позволяет динамически обновлять токены воркеров.

### Режим Чистого Холона (Pure Holon Mode)
Для сред с повышенными требованиями к безопасности или при работе в качестве Составного Холона (Compound Holon) внутри HLN, вы можете отключить публичный API для клиентов.
*   **Включение/Отключение**: Установите `ENABLE_CLIENT_API="false"` (по умолчанию: `true`).
*   **Эффект**: Оркестратор перестанет слушать на `/api/v1/jobs/...`. Он будет принимать задачи только через Протокол Воркера (RXON) от своего родителя.

### Наблюдаемость

При установке с зависимостью telemetry, система автоматически предоставляет:

*   **Метрики Prometheus**: Доступны по адресу `/_public/metrics`.
*   **Распределенная трассировка**: Совместима с OpenTelemetry и системами типа Jaeger или Zipkin.

## Руководство участника

### Настройка окружения

*   Клонируйте репозиторий.
*   **Для локальной разработки** сначала установите пакет протокола:
    ```bash
    pip install -e ../rxon
    ```
*   Затем установите пакет движка в редактируемом режиме со всеми зависимостями:
    ```bash
    pip install -e ".[all,test]"
    ```
*   Убедитесь, что у вас установлены системные зависимости, такие как `graphviz`.
    *   Debian/Ubuntu:
        ```bash
        sudo apt-get install graphviz
        ```
    *   macOS (Homebrew):
        ```bash
        brew install graphviz
        ```

### Запуск тестов

Для запуска набора тестов `avtomatika`:
```bash
pytest tests/
```

### Интерактивная документация API

Avtomatika предоставляет встроенную страницу интерактивной документации API (похожую на Swagger UI), которая автоматически генерируется на основе ваших зарегистрированных блупринтов.

*   **Эндпоинт:** `/_public/docs`
*   **Возможности:**
    *   **Список всех системных эндпоинтов:** Подробная документация для публичных, защищенных и API воркеров.
    *   **Динамическая документация блупринтов:** Автоматически генерирует и перечисляет документацию для всех блупринтов, зарегистрированных в движке, включая их специфические API-эндпоинты.
    *   **Интерактивное тестирование:** Позволяет тестировать вызовы API прямо из браузера. Вы можете указать токены аутентификации, параметры и тела запросов, чтобы увидеть реальные ответы сервера.

## Подробная документация

Для более глубокого погружения в систему, пожалуйста, обратитесь к следующим документам:

-   [**Архитектурный гайд**](architecture.md): Подробный обзор компонентов системы и их взаимодействия.
-   [**Справочник API**](api_reference.md): Полная спецификация HTTP API.
-   [**Гайд по развертыванию**](deployment.md): Инструкции по развертыванию с Gunicorn/Uvicorn и NGINX.
-   [**Cookbook**](cookbook/README.md): Примеры и лучшие практики для создания блупринтов.